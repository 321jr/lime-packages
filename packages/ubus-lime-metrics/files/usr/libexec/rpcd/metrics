#!/usr/bin/env lua
--[[
  Copyright (C) 2013-2017 LibreMesh.org
  This is free software, licensed under the GNU AFFERO GENERAL PUBLIC LICENSE Version 3

  Copyright 2017 Marcos Gutierrez <gmarcos@altermindi.net>
  Copyright 2017 Nicolas Echaniz <nicoechaniz@altermundi.net>
]]--

require "ubus"
require "uloop"

local function shell(command)
    -- TODO(nicoechaniz): sanitize or evaluate if this is a security risk
    local handle = io.popen(command)
    local result = handle:read("*a")
    handle:close()
    return result
end

uloop.init()

local conn = ubus.connect()
if not conn then
    error("Failed to connect to ubus")
end

local function file_exists(file)
    -- check if the file exists
    local f = io.open(file, "rb")
    if f then f:close() end
    return f ~= nil
end

local function list_from_file(file)
    -- get all lines from a file with one value per line and return a list type table
    -- return an empty table if the file does not exist
    if not file_exists(file) then return {} end
    local list = {}
    for line in io.lines(file) do
        table.insert(list, line)
    end
    return list
end

local function _nslookup_working()
    local shell_output = shell("nslookup google.com | grep Name -A2 | grep Address")
    return shell_output
end

local function _get_loss(host, ip_version)
    local ping_cmd = "ping"
    if ip_version then
        if ip_version == 6 then
            ping_cmd = "ping6"
        end
    end
    local shell_output = shell(ping_cmd.." -q  -i 0.1 -c4 -w2 "..host)
    local loss = "100"
    if shell_output ~= "" then
        loss = shell_output:match("(%d*)%% packet loss")
    end
    return loss
end

local function _get_metrics(target)
    local result = {}
    local node = target
    local loss = _get_loss(node..".mesh", 6)
    shell_output = shell("netperf -6 -l 10 -H "..node..".mesh| tail -n1| awk '{ print $5 }'")
    local bw = 0
    if shell_output ~= "" then
        bw = shell_output:match("[%d.]+")
    end
    result.loss = loss
    result.bandwidth = bw
    result.status = "ok"
    return result
end

local function get_metrics(req, msg)
    conn:reply(req, {status="processing"})
    local def_req = conn:defer_request(req)
    uloop.timer(function()
            local result = _get_metrics(msg.target)
            conn:reply(def_req, result)
            conn:complete_deferred_request(def_req, 0)
            print("Deferred request complete")
                end, 500)
    print("Call to function 'deferred'")
end

local function _get_gateway() 
    local result = {}
    local default_dev = shell("ip r | grep 'default dev' | cut -d' ' -f3")
    if default_dev ~= "" then
        local shell_output = shell("bmx6 -c show tunnels | grep "..default_dev.." | grep inet4 ")
        local res = {}
        for w in shell_output:gmatch("%S+") do table.insert(res, w) end
        local gw = res[10]
        result.status = "ok"
        result.gateway = gw
        return result
    else
        return {status="error", error={msg="Not found. No gateway available.", code="1"}}
    end

end
local function get_gateway(req, msg)
    conn:reply(req, _get_gateway())
end

local function _get_path(target)
    local node = target
    local result = {}
    local path = {}
    local path_str = shell("traceroute6 -q 1 "..node..".mesh | grep ms | awk '{ print $2 }' | cut -d'.' -f1")
    for l in path_str:gmatch("[^\n]*") do
        if l ~= "" then
            table.insert(path, l)
        end
    end
    result.path = path
    result.status = "ok"
    return result
end
local function get_path(req, msg)
    conn:reply(req,_get_path(msg.target))
end

local function get_last_internet_path(req, msg)
    local path = list_from_file("/etc/last_internet_path")
    local result = {}
    if #path>0 then
        result.path = {}
        for i, node in ipairs(path) do
            table.insert(result.path, node)
        end
        result.status = "ok"
    else
        result = {status="error", error={msg="Not found. No known Internet path.", code="1"}}
    end
    conn:reply(req,result)
end

local function get_internet_status(req, msg)
    local result = {}
    local lossV4 = _get_loss("4.2.2.2")
    if lossV4 ~= "100" then
        result.IPv4 = { working=true }
    else
      result.IPv4 = { working=false }
    end

    local lossV6 = _get_loss("2600::", 6)
    if lossV6 ~= "100" then
        result.IPv6 = { working=true }
    else
      result.IPv6 = { working=false }
    end
    local lookup_output = _nslookup_working()
    if lookup_output ~= "" then
        result.DNS = { working=true }
    else
        result.DNS = { working=false }
    end
    result.status = "ok"
    conn:reply(req, result)
end

get_station_traffic(req,msg)
    local iface = msg.iface
    local mac = msg.station_mac
    local result = {}
    local traffic = orange.shell("iw "..iface.." station get "..mac.." | grep bytes | awk '{ print $3}'")
    words = {}
    for w in traffic:gmatch("[^\n]+") do table.insert(words, w) end
    rx = words[1]
    tx = words[2]
    result.station = mac
    result.rx_bytes = tonumber(rx, 10)
    result.tx_bytes = tonumber(tx, 10)
    result.status = "ok"
    call:reply(req, result)
end

local module = {}
module['lime.metrics'] = {
	get_metrics = { get_metrics, { target = ubus.STRING } },
    get_gateway = { get_gateway, {} },
    get_path = { get_path, { target = ubus.STRING } },
    get_last_internet_path = { get_last_internet_path, { } },
    get_internet_status = { get_internet_status, { } },
    get_station_traffic = { get_station_traffic, { iface: ubus.STRING, station_mac: ubus.STRING } }
}


conn:add(module)

uloop.run()