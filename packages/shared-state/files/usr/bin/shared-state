#!/usr/bin/lua

--! LibreMesh
--! Copyright (C) 2019  Gioacchino Mazzurco <gio@altermundi.net>
--!
--! This program is free software: you can redistribute it and/or modify
--! it under the terms of the GNU Affero General Public License as
--! published by the Free Software Foundation, either version 3 of the
--! License, or (at your option) any later version.
--!
--! This program is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--! GNU Affero General Public License for more details.
--!
--! You should have received a copy of the GNU Affero General Public License
--! along with this program.  If not, see <http://www.gnu.org/licenses/>.

local fs = require("nixio.fs")
local http = require("luci.httpclient")
local JSON = require("luci.jsonc")
local nixio = require("nixio")

sharedState = {}

--! Map<Key, {timeout, author, data}>
sharedState.storage = {}

sharedState.changed = false
sharedState.locked = false
sharedState.dataType = "unspecified"
sharedState.dataDir = "/var/shared-state/data/"
sharedState.hooksDir = "/etc/shared-state/hooks/"

function sharedState.dataStorePath()
	return sharedState.dataDir..sharedState.dataType..".json"
end

local function log(str) io.stderr:write(str) end

function sharedState.insert(key, data, timeout)
	timeout = timeout or (os.time() + 3600)
	sharedState.storage[key] = {
		timeout=timeout,
		author=io.input("/proc/sys/kernel/hostname"):read("*line"),
		data=data
	}
	sharedState.changed = true
end

function sharedState.remove(key)
	if(sharedState.storage[key] ~= nil and sharedState.storage[key].data ~= nil)
	then sharedState.insert(key, nil) end
end

function sharedState.sync(stateSlice, notifyInsert)
	local stateSlice = stateSlice or {}
	if(notifyInsert == nil) then notifyInsert = true end

	for key, rv in pairs(stateSlice) do
		if(rv.timeout < os.time()) then
			log("sharedState.sync got expired entry: "..key)
			log(" expired on: "..os.date("%c", rv.timeout).."\n")
			sharedState.changed = true
		else
			local lv = sharedState.storage[key]
			if( lv == nil ) then
				log("Load entry for: "..key.." will expire on: ")
				log(os.date("%c", rv.timeout).."\n")
				sharedState.storage[key] = rv
				sharedState.changed = sharedState.changed or notifyInsert
			elseif ( lv.timeout < rv.timeout ) then
				log("Updating entry for: "..key.." older: ")
				log(os.date("%c", lv.timeout).." newer: ")
				log(os.date("%c", rv.timeout).."\n")
				sharedState.storage[key] = rv
				sharedState.changed = sharedState.changed or notifyInsert
			end
		end
	end
end

function sharedState.load(mPath)
	mPath = mPath or sharedState.dataStorePath()
	if(fs.stat(mPath) ~= nil) then
		sharedState.sync(JSON.parse(io.input(mPath):read("*all")), false)
	end
end

function sharedState.toJsonString()
	return JSON.stringify(sharedState.storage)
end

function sharedState.save(mPath)
	mPath = mPath or sharedState.dataStorePath()
	fs.mkdirr(fs.dirname(mPath))
	local outStr = sharedState.toJsonString()
	if mPath == "/dev/stdout" then print(outStr)
	else
		local outFile = io.open(mPath, "w")
		outFile:write(outStr)
		outFile:close()
	end
end

if arg[2] then sharedState.dataType = arg[2] end

for i=1,10 do
	if not os.execute("mkdir "..sharedState.dataStorePath()..".lock >/dev/null 2>&1") then
		nixio.nanosleep(0, 10000000000)
	else
		sharedState.locked = true
		break
	end
end

if not sharedState.locked then
	log(arg[0].."Failed acquiring lock of data\n")
	os.exit(false)
end

sharedState.load()


if arg[1] == "insert" then
	local inputTable = JSON.parse(io.stdin:read("*all")) or {}
	for key, lv in pairs(inputTable) do sharedState.insert(key, lv) end
elseif arg[1] == "get" then
	sharedState.save("/dev/stdout")
elseif arg[1] == "sync" then
	local urls = {}

	if arg[3] == nil then
		io.input(io.popen(arg[0].."-get_candidates_neigh"))
		for line in io.lines() do
			table.insert(
				urls,
				"http://["..line.."]/cgi-bin/shared-state/"..sharedState.dataType )
		end
	else for i=3,#arg do table.insert(urls, arg[i]) end end

	for _,url in ipairs(urls) do
		local options = {}
		options.sndtimeo = 3
		options.rcvtimeo = 3
		options.method = 'POST'
		options.body = sharedState.toJsonString()

		local response = http.request_to_buffer(url, options)
		if type(response) == "string" and response:len() > 1  then
			local parsedJson = JSON.parse(response)
			if parsedJson then sharedState.sync(parsedJson) end
		end
	end
elseif arg[1] == "reqsync" then
	sharedState.sync(JSON.parse(io.stdin:read("*all")))
	sharedState.save("/dev/stdout")
elseif arg[1] == "remove" then
	local inputTable = JSON.parse(io.stdin:read("*all"))
	if inputTable ~= nil then
		for _,key in ipairs(inputTable) do sharedState.remove(key) end
	end
else
	log(arg[0].." is not able to self manage, needs a command\n")
	return -22
end

if sharedState.changed then sharedState.save() end
os.execute("rmdir "..sharedState.dataStorePath()..".lock")


if sharedState.changed then
	for hook in fs.dir(sharedState.hooksDir..sharedState.dataType) do
		local hookPath = sharedState.hooksDir..sharedState.dataType.."/"..hook
		local retval = os.execute(hookPath);
		log("Executed hook: "..hookPath.." "..retval.."\n")
	end
end
