#!/usr/bin/lua

local fs  = require "nixio.fs"
local uci = require "uci"
local iw  = require "iwinfo"

local x = uci:cursor()

local function split(string, sep)
	local ret = {}
	for token in string.gmatch(string, "[^"..sep.."]+") do
		table.insert(ret, token)
	end
	return ret
end

local function node_id()
	local dev = assert(x:get("lime", "network", "primary_dev"))
	local mac = assert(fs.readfile("/sys/class/net/"..dev.."/address"))
	local t = split(mac, ":")
	local r1, r2, r3 = tonumber(t[#t-2], 16), tonumber(t[#t-1], 16), tonumber(t[#t], 16)
	return r1, r2, r3
end

local function network_id()
	local network_essid = assert(x:get("lime", "wireless", "ssid"))
	local n1, n2, n3
	local fd = io.popen('echo "' .. network_essid .. '" | md5sum')
	if fd then
		local md5 = fd:read("*a")
		n1 = tonumber(md5:match("^(..)"), 16)
		n2 = tonumber(md5:match("^..(..)"), 16)
		n3 = tonumber(md5:match("^....(..)"), 16)
		fd:close()
	end
	return n1, n2, n3
end

local function generate_address(p, n)
	local id = n
	local r1, r2, r3 = node_id()
	local n1, n2, n3 = network_id()
	local ipv4_template = assert(x:get("lime", "network", "ipv4_net"))
	local ipv6_template = assert(x:get("lime", "network", "ipv6_net"))

	local function hex(x) return string.format("%02x", x) end

	ipv6_template = ipv6_template:gsub("N1", hex(n1)):gsub("N2", hex(n2)):gsub("N3", hex(n3))

	return ipv4_template:gsub("R1", r1):gsub("R2", r2):gsub("R3", r3 + id),
	       ipv6_template:gsub("R1", hex(r1)):gsub("R2", hex(r2)):gsub("R3", hex(r3 + id))
end

local function generate_ssid()
	local id = assert(x:get("lime", "wireless", "ssid"))
	local r1, r2, r3 = node_id()

	return string.format("%02x%02x%02x.%s", r1, r2, r3, id)
end

local function set_hostname()
	local r1, r2, r3 = node_id()
	local hostname = string.format("%02x%02x%02x", r1, r2, r3)

	x:foreach("system", "system", function(s)
		x:set("system", s[".name"], "hostname", hostname)
	end)
	x:save("system")
	x:commit("system")

	fs.writefile("/proc/sys/kernel/hostname", hostname)
end

local function printf(fmt, ...)
	print(string.format(fmt, ...))
end

function main()
	local protocols = assert(x:get("lime", "network", "protos"))
	local vlans = assert(x:get("lime", "network", "vlans"))
	local n1, n2, n3 = network_id()
	local r1, r2, r3 = node_id()
	local batch = { }

	print("Disabling v6 firewall")
	fs.writefile("/etc/firewall.user", "ip6tables -P INPUT ACCEPT\nip6tables -P OUTPUT ACCEPT\nip6tables -P FORWARD ACCEPT\n")
	x:foreach("firewall", "defaults", function(s)
		x:set("firewall", s[".name"], "disable_ipv6", "1")
	end)
	x:save("firewall")
	x:commit("firewall")

	print("Clearing network config...")
	x:foreach("network", "interface", function(s)
		if s[".name"]:match("^lm_") then
			x:delete("network", s[".name"])
		end
	end)

	print("Disabling 6relayd...")
	fs.writefile("/etc/config/6relayd", "")

	local v4, v6 = generate_address(1, 0) -- for br-lan
	x:set("network", "lan", "ip6addr", v6)
	x:set("network", "lan", "ifname", "eth0 bat0")

  -- For batadv use a vlan based off network_id, between 16 and 255, if uci doesn't specify a vlan
	if not vlans[2] then vlans[2] = math.floor(16 + ((tonumber(n1) / 255) * (255 - 16))) end

	-- Add vlan interfaces on top of ethernet, for each proto. Eg. lm_eth_batadv
	local n
	for n = 1, #protocols do
		local net = "lm_eth_" .. protocols[n]
		local ifn = string.format("eth1.%d", vlans[n])
		local v4, v6 = generate_address(n, 0)

		x:set("network", net, "interface")
		x:set("network", net, "ifname", ifn)
		x:set("network", net, "proto", "none")
		x:set("network", net, "auto", "1")

		local cmd = string.format("sh /etc/lime/protos/%s.sh add %s %s %s %s %d %d %d",
			protocols[n], net, ifn, v4, v6, r1, r2, r3)

		batch[#batch+1] = cmd
	end

	x:save("wireless")
	x:save("network")
	x:commit("wireless")
	x:commit("network")

	print("Clearing wireless config...")
	x:foreach("wireless", "wifi-iface", function(s) x:delete("wireless", s[".name"]) end)

	print("Preparing protocols...")
	local _, p
	for _, p in ipairs(protocols) do
		local cmd = string.format("sh /etc/lime/protos/%s.sh prepare", p)
		printf("-> Calling %s", cmd)
		os.execute(cmd)
	end

	print("Defining wireless networks...")
	local channel2 = assert(x:get("lime", "wireless", "mesh_channel_2ghz"))
	local channel5 = assert(x:get("lime", "wireless", "mesh_channel_5ghz"))
	local mcast_rate_2 = assert(x:get("lime", "wireless", "mesh_mcast_rate_2ghz"))
	local mcast_rate_5 = assert(x:get("lime", "wireless", "mesh_mcast_rate_5ghz"))
	local wifi_num = 0

	x:foreach("wireless", "wifi-device", function(s)
		local t = iw.type(s[".name"])
		if not t then return end

		local is_5ghz = iw[t].hwmodelist(s[".name"]).a
		local ch = table.remove(is_5ghz and channel5 or channel2, 1)
		local mcr = is_5ghz and mcast_rate_5 or mcast_rate_2
		local id = string.format("mesh%d", wifi_num)
		local net = "lm_" .. id
		local ifn = string.format("mesh%d", wifi_num)
		local ifn_ap = string.format("wlan%dap", wifi_num)

		if not ch then
			printf("-> No channel defined for %dGHz %s", is_5ghz and 5 or 2, s[".name"])
			return
		end

		local ht = ch:match("[-+]?$")

		printf("-> Using channel %s for %dGHz %s", ch, is_5ghz and 5 or 2, s[".name"])
		x:set("wireless", s[".name"], "channel", (ch:gsub("[-+]$", "")))

		if x:get("wireless", s[".name"], "ht_capab") then
			if ht == "+" or ht == "-" then
				x:set("wireless", s[".name"], "htmode", "HT40"..ht)
			else
				x:set("wireless", s[".name"], "htmode", "HT20")
			end
		end

		x:set("wireless", s[".name"], "disabled", 0)

		x:set("wireless", id, "wifi-iface")
		x:set("wireless", id, "mode", "adhoc")
		x:set("wireless", id, "device", s[".name"])
		x:set("wireless", id, "network", net)
		x:set("wireless", id, "ifname", ifn)
		x:set("wireless", id, "mcast_rate", mcr)
		x:set("wireless", id, "ssid", generate_ssid())
		x:set("wireless", id, "bssid", assert(x:get("lime", "wireless", "mesh_bssid")))

		x:set("wireless", ifn_ap, "wifi-iface")
		x:set("wireless", ifn_ap, "mode", "ap")
		x:set("wireless", ifn_ap, "device", s[".name"])
		x:set("wireless", ifn_ap, "network", "lan")
		x:set("wireless", ifn_ap, "ifname", ifn_ap)
		x:set("wireless", ifn_ap, "ssid", assert(x:get("lime", "wireless", "ssid")))

		x:set("network", net, "interface")
		x:set("network", net, "proto", "none")
		x:set("network", net, "mtu", "1528")


		-- Add vlan interfaces on top of wlans, for each proto. Eg. lm_mesh0_batadv
		local n
		for n = 1, #protocols do
			local v4, v6 = generate_address(n, wifi_num)

			net = "lm_" .. id .. "_" .. protocols[n]
			x:set("network", net, "interface")
			x:set("network", net, "proto", "none")
			x:set("network", net, "auto", "1")
			x:set("network", net, "ifname", string.format("@lm_%s.%d", id, vlans[n]))

			local cmd = string.format("sh /etc/lime/protos/%s.sh add %s %s.%d %s %s",
				protocols[n], net, ifn, vlans[n], v4, v6)

			batch[#batch+1] = cmd
		end

		wifi_num = wifi_num + 1
	end)

	print("Committing config files...")
	x:save("network")
	x:save("wireless")
	x:commit("network")
	x:commit("wireless")

	print("Ugly overwrite of /etc/rc.local to make it add macvlan interface...")
	local anygw_mac = string.format("aa:aa:aa:%02x:%02x:%02x", n1, n2, n3)
	local _, v6 = generate_address(1, 0) -- for anygw
	local v6prefix = v6:match("^([^:]+:[^:]+:[^:]+):")
	local anygw_ipv6 = string.format(v6prefix .. "::1/64")
	local content = { }
	table.insert(content, "ip link add link br-lan anygw address " .. anygw_mac .. " type macvlan")
	table.insert(content, "ip address add dev anygw " .. anygw_ipv6)
	table.insert(content, "ip link set anygw up")
	table.insert(content, "exit 0")
	fs.writefile("/etc/rc.local", table.concat(content, "\n"))

	print("Enabling RA in dnsmasq...")
	content = { }
	table.insert(content, "enable-ra")
	table.insert(content, string.format("dhcp-range=%s::, ra-names", v6prefix))
	table.insert(content, "dhcp-option=option6:domain-search, lan")
	fs.writefile("/etc/dnsmasq.conf", table.concat(content, "\n").."\n")

	print("Configuring system...")
	set_hostname()

	print("Configuring protocols...")
	local _, cmd
	for _, cmd in ipairs(batch) do
		printf("-> Calling %s", cmd)
		os.execute(cmd)
	end
end

main()
